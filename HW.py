

cSet = 300 
cMar = 100
cPen = 1600
# [食物品項, CP值(滿意度/熱量), 熱量 : 卡, 價格 : 元, 滿意度 : 分]
Food = [['原汁牛肉麵', 0.1329, 677, 115, 90], 
        ['叻沙牛肉麵', 0.0847, 945, 125, 80], 
        ['花生熔岩卡啦雞腿堡(辣)', 0.1257, 716, 129, 90], 
        ['功夫麵', 0.2833, 300, 85, 85], 
        ['烤雞排', 0.2833, 300, 90, 85], 
        ['魷魚羹麵', 0.2162, 370, 70, 80], 
        ['石鍋拌飯', 0.1086, 875, 120, 95], 
        ['炸豬排飯', 0.1579, 570, 110, 90], 
        ['雙層牛肉吉司堡', 0.1932, 440, 105, 85], 
        ['咖喱飯', 0.1727, 550, 120, 95], 
        ['雞胸肉健康餐', 0.1556, 450, 135, 70], 
        ['涼麵', 0.1974, 380, 60, 75]]
Dish = ['原汁牛肉麵', '叻沙牛肉麵', '花生熔岩卡啦雞腿堡(辣)', '功夫麵', '烤雞排', '魷魚羹麵', '石鍋拌飯', '炸豬排飯', '雙層牛肉吉司堡', '咖喱飯', '雞胸肉健康餐', '涼麵']
# Sati/Cal/Price
Cal = [677, 945, 716, 300, 300, 370, 875, 570, 440, 550, 450, 380]
Price = [115, 125, 129, 85, 90, 70, 120, 110, 105, 120, 135, 60]
Sati = [90, 80, 90, 85, 85, 80, 95, 90, 85, 95, 70, 75]


Dishes = {
    '品項': ['叻沙牛肉麵', '石鍋拌飯', '花生雞腿堡', '原汁牛肉麵', '炸豬排飯', '咖哩飯', '雞胸肉餐', '雙層牛肉吉士堡', '涼麵', '魷魚羹', '功夫麵', '烤雞排'], 
    '熱量': [945, 875, 716, 677, 570, 550, 450, 440, 380, 370, 300, 300], 
    '價格': [160, 140, 129, 115, 110, 120, 135, 105, 60, 70, 65, 60], 
    '滿意度': [140, 120, 99, 95, 90, 88, 85, 80, 75, 70, 60, 55],
    # '整體滿意度' = (1/熱量)*20000+(1/價格)*1000+喜愛程度
    '整體滿意度': [167.41, 150.00, 134.68, 133.24, 134.18, 132.70, 136.85, 134.98, 144.30, 138.34, 142.05, 138.33]
}

T = 7 # 總期數
Sn = 800 # 剩下的餐費
Xn = {} # 選擇哪項餐點
K = {} #裝各期最佳key值
S = [] #裝各期各x下的value
Days = 3 #幾天內重複吃同餐點滿意度會下降
R = {}  #裝各期的recursive，即該期最佳cost
D = []
S = [[[]]*len(Cal)  for i in range(T+1)]



for t in range(T, 0, -1):
    for i in range(0 , len(Cal)): # 所有的餐點都嘗試看看
        IsChoosen = D[-Days:].count(Dish[i]) #確認過去幾天是否吃過相同餐點
        S[t][i] = Sati[i]*0.8**IsChoosen/Price[i]/Cal[i] # 紀錄當下cost
        print(0.7**IsChoosen)
    maxval = max(S[t]) #找出當期最大值 
    Index = S[t].index(maxval) #找出當期最大值為第幾期
    D.append(Dish[Index])
    R[t] = maxval # 當期最小的cost 
    # for v in S[t]:
    #     if S[t][v] == maxval:
    #         if t not in K:
    #             K[t] = [v[1]]  #第t期的最佳解是X=x
    #         else:
    #             K[t].append(v[1])
# print(S)
print(D)
# print('----'*10)
# print(K)
# print('----'*10)
# print(R)














# CP = {}
# R = {}  #裝各期的recursive，即該期最佳cost
# S = {} #裝各期各x下的value
# K = {} #裝各期最佳key值
# X = 6 # 商品最大數量
# T = 3 
# for t in range(T, 0, -1): # 建立字典中的字典，每個小字典裝當期值
#     S[t] = {}
# for t in range(T, 0, -1): # 執行backward induction
#     for x in range(0 , X+1): # 所有的生產量都嘗試看看
#         if t == T: # 如果現在是最後一期
#             if x == 0 :
#                 reward = 0
#             else:
#                 reward = cSet + x * cMar
#             value = reward + ((1/2)**x) * 1600
#         else: # 否則
#             if x == 0:
#                 reward = 0
#             else:
#                 reward = cSet + x * cMar
#             value = reward + ((1/2)**x) * R[t+1]
#         S[t][t, x] = value # 紀錄當下cost
        
#     minval = min(S[t].values()) #找出當期最小值 
#     R[t] = minval # 當期最小的cost
    
    # for v in S[t]:
    #     if S[t][v] == minval:
    #         if t not in K:
    #             K[t] = [v[1]]  #第t期的最佳解是X=x
    #         else:
    #             K[t].append(v[1])
# print(K)
# print('----'*10)
# print(R)
# print('----'*10)
# for i in S:
#     print(S[i])
